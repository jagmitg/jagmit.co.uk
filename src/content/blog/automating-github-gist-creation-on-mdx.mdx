---
title: Automating GitHub Gists Creation for MDX Documentation
date: '2025-02-18'
description: Building a custom UK Pension Projection Calculator to see what pensions look like for you in the future built with React & Tailwind.
image: /images/blog/automating-github-gist-creation-on-mdx/mdx-creation.png
tags: [typescript, astro]
draft: false
---

As a technical writer and developer, I found myself spending too much time manually copying code snippets from my MDX documentation, creating GitHub Gists, and then pasting the Gist references back. This repetitive process was not only time-consuming but also prone to errors. Today, I'll share how I automated this workflow using the GitHub Gists API.

## The Problem

When writing technical documentation in MDX, I often include code examples. To keep the repository clean and the documentation maintainable, I prefer to store code snippets as GitHub Gists and reference them in my MDX files. However, this process typically involves:

1. Finding code blocks in MDX files
2. Manually creating Gists for each code block
3. Copying the Gist ID and filename
4. Replacing the original code block with a Gist reference
5. Repeating this process for every code block in every MDX file

For a documentation site with dozens of files, this becomes a significant time sink.

## The Solution: Automation with GitHub's Gist API

I created a TypeScript script that automates this entire process. The script:

- Recursively finds all MDX files in a directory
- Extracts code blocks from each file
- Creates GitHub Gists automatically
- Updates the MDX files with the proper Gist references

<code
	data-gist-id="aa5cc76f0fdccf7fb00da11e73126f77"
	data-gist-file="processFile.ts"
></code>

## Key Features

1. **Smart Code Block Detection**: The script identifies code blocks in MDX files using regex patterns that match the standard markdown code fence syntax (```) along with a filename.
2. **Grouped Gists**: Instead of creating separate Gists for each code block, related code blocks from the same MDX file are grouped into a single Gist with multiple files.
3. **Environment Configuration**: The script uses environment variables for configuration, making it easy to use in different environments:

<code
	data-gist-id="aa5cc76f0fdccf7fb00da11e73126f77"
	data-gist-file="main_two.ts"
></code>

4. **Error Handling**: The script includes comprehensive error handling to ensure reliability:

- Validates environment variables
- Handles API errors gracefully
- Provides detailed error messages
- Continues processing even if one file fails

## Setting Up the Automation

To use this automation in your own projects:

1. Create a `.env` file with your GitHub Personal Access Token and directory path:

<code
	data-gist-id="aa5cc76f0fdccf7fb00da11e73126f77"
	data-gist-file="envrionment_file.env"
></code>

2. Install the required dependencies:

<code
	data-gist-id="aa5cc76f0fdccf7fb00da11e73126f77"
	data-gist-file="dotenv.sh"
></code>

3. Run the script:

<code
	data-gist-id="aa5cc76f0fdccf7fb00da11e73126f77"
	data-gist-file="dotenv_two.sh"
></code>

## The Results

After implementing this automation, what used to take hours of manual work now takes seconds. The script processes all MDX files in the specified directory, creates appropriate Gists, and updates the documentation automatically.

The output gets transformed into

<code
	data-gist-id="aa5cc76f0fdccf7fb00da11e73126f77"
	data-gist-file="code.ts"
></code>

## Future Improvements

While the current implementation serves its purpose well, there are several potential improvements:

1. Add support for more code block formats
2. Implement batch processing for better API rate limit handling
3. Add a dry-run mode for testing
4. Create a CLI interface for better usability
5. Add support for updating existing Gists instead of creating new ones

## Conclusion

Automation doesn't always have to be about complex systems or large-scale operations. Sometimes, automating simple, repetitive tasks can save significant time and reduce errors in our daily workflows. This Gist automation script is a perfect example of how a small automation tool can make documentation maintenance much more efficient.
The complete code for this automation is available in the example above, and you can adapt it to your own documentation workflow. Happy automating!
